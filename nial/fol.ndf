% predicate logic in nial
% --------------------------------------------------

ok := null;

reload is { loaddefs "fol };

head is first;

dump is op x { write display x };
check is op msg pred { if pred then ok else write msg break endif };

unquote is op q {
  link descan scan link descan deparse q };

chkev is op q {
  if eval q then ok
  else write 'failed: ' (unquote q); break endif };

words is op Str {
   % from towords.ndf in nial distro;
   Strings := EACH phrase ( `  match Str cut Str ) }


% logical language
% --------------------------------------------------

consts glyphs := cols mix [
  "forall '∀',
  "exists '∃',
  "top    '⊤',
  "bot    '⊥'
];

isconst is op k { k in consts };
glyph is op k { glyphs@( find k consts )};


% unification
% --------------------------------------------------

unify is op x y {
  if x = y then []
  else "no endif }

chkev !( unify "a "a = [] );
chkev !( unify "a "z = "no );


% logic symbols
% --------------------------------------------------

show is op x {
  if isboolean x then
    result := if x then glyph "top else glyph "bot endif
  elseif isphrase x then
    result := if isconst x
      then glyph x
      else string x
    endif
  else
    result := link each string (link each show x)
  endif;
  link (each string result) }


% test suite
% --------------------------------------------------

chk is op want tree {
  got := show tree;
  if want = got then ok
  else write link[ 'mismatch:', display [want, got]] endif }

chk '⊤' "top; chk '⊥' "bot;
chk '⊥⊥' oo; chk '⊤⊥' lo; % booloan literals;
chk '∀' "forall; chk '∃' "exists;
chk 'x' "x; chk 'Px' ("P "x);
chk '∀xPx' ["forall "x ["P "x]];


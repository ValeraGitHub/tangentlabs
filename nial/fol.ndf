% predicate logic in nial


% helpers;
% --------------------------------------------------;
ok := null;

reload is { loaddefs "fol };

head is first;
tail is rest;

dump is op x { write display x };
check is op msg pred { if pred then ok else fault msg endif };

unquote is op q {
  link descan scan link descan deparse q };

assert is op q {
  if eval q then ok
  else write 'failed: ' (unquote q) endif };

esc := char 27;
bold := link esc '[0;1m';
plain := link esc '[0m';

emit is op a { writescreen a };

cheq is op q0 q1 {
  emit (link bold 'testing: ' (unquote q0) plain);
  v0 v1 := each eval q0 q1;
  if v0 = v1 then ok
  else write (
    link 'failed: ' (unquote q0) ' : ' (display v0) ' != ' (display v1))
  endif };

words is op Str {
   % from towords.ndf in nial distro;
   Strings := EACH phrase ( `  match Str cut Str ) }


% logical language
% --------------------------------------------------;

consts glyphs := cols mix [
  "forall '∀',
  "exists '∃',
  "top    '⊤',
  "bot    '⊥'
];

isconst is op k { k in consts };
glyph is op k { glyphs@( find k consts )};


% substitution
% --------------------------------------------------;

any is tr p (or each p);

subs is op dict expr {
  if any empty dict expr then expr
  else ok;
    k v := cols ((floor(tally dict /2) 2) reshape dict);
    res := null;
    for item with expr do
      if k = solitary item
        then res := res link v@0
      elseif item in k
        then res := res link (v@( find item k ))
        else res := res link item
      endif
    endfor
  endif }

cheq !( subs ("a 1) "a )      !( [1] );
cheq !( subs ("a 1) ("a "a))  !( 1 1 );
cheq !( subs ("a 1) ["a])     !( [1] );
cheq !( subs ("a 1) [] )      !( [] );

(cheq !( subs ("a 1 "b 2) ("a "b "a))
      !( 1 2 1 ))

% unification
% --------------------------------------------------;

id is pass;
intree is op x tree {x in (link leaf id tree)};
isvar is op x {
  if and[isphrase, not isconst] x
  then =[id, tolower] string x else o endif };


unify is op x y {
  if x = y then []
  elseif and[isvar x, not or[isvar y, x intree y]] then [ x, y ]
  elseif and[isvar y, not or[isvar x, y intree x]] then [ y, x ]
  elseif or[atomic x, atomic y, not match each tally x y] then "no
  else
    begin
      if (shape x) ~= (shape y) then "no
      else
        hu := unify (each head x y);
        if hu = "no then "no
        else
          tu := (unify (each ((hu subs) tail) x y));
          if tu = "no then "no
          else hu link tu endif
        endif
      endif
    end
  endif }


% unification tests;

% 0 variables;
cheq !( unify 0 0 )     !( [] );
cheq !( unify 0 1 )     !( "no );

% single variable;

cheq !( unify "a "a )     !( [] );
cheq !( unify "a ["x "a]) !( "no );
cheq !( unify "a 5 )      !( ["a, 5] );

cheq !( unify [ 1 "vs "a] [ 1 "vs 2]) !( "a 2 );
cheq !( unify [ 1 "vs  2] ["x "vs 2]) !( "x 1 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );

cheq !( unify ["a "a] [1 2]) !( "no );
cheq !( unify ["a "a] [1 1]) !( "a 1 );

% logic symbols
% --------------------------------------------------;

show is op x {
  if isboolean x then
    result := if x then glyph "top else glyph "bot endif
  elseif isphrase x then
    result := if isconst x
      then glyph x
      else string x
    endif
  else
    result := link each string (link each show x)
  endif;
  link (each string result) }

% tests for 'show';

chk is op want tree {
  got := show tree;
  if want = got then ok
  else write link[ 'mismatch:', display [want, got]] endif }

chk '⊤' "top; chk '⊥' "bot;
chk '⊥⊥' oo; chk '⊤⊥' lo; % booloan literals;
chk '∀' "forall; chk '∃' "exists;
chk 'x' "x; chk 'Px' ("P "x);
chk '∀xPx' ["forall "x ["P "x]];


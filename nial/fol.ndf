% predicate logic in nial


% helpers;
% --------------------------------------------------;
ok := null;

reload is { loaddefs "fol };

head is first;
tail is rest;

dump is op x { write display x };
check is op msg pred { if pred then ok else fault msg endif };

unquote is op q {
  link descan scan link descan deparse q };

assert is op q {
  if eval q then ok
  else write 'failed: ' (unquote q) endif };

esc := char 27;
bold := link esc '[0;1m';
plain := link esc '[0m';

emit is op a { writescreen a };

cheq is op q0 q1 {
  emit (link bold 'testing: ' (unquote q0) plain);
  v0 v1 := each eval q0 q1;
  if v0 = v1 then ok
  else write (
    link 'failed: ' (unquote q0) ' : ' (display v0) ' != ' (display v1))
  endif };

words is op Str {
   % from towords.ndf in nial distro;
   Strings := EACH phrase ( `  match Str cut Str ) }


% logical language
% --------------------------------------------------;

consts glyphs := cols mix [
  "forall '∀',
  "exists '∃',
  "top    '⊤',
  "bot    '⊥'
];

isconst is op k { k in consts };
glyph is op k { glyphs@( find k consts )};


% substitution
% --------------------------------------------------;

any is tr p (or each p);

subs is op dict expr {
  if any empty dict expr then expr
  else
    k v := cols ((floor(tally dict /2) 2) reshape dict);
    if expr in k then v@( find expr k )
    else each (op item {
      if k = solitary item then
        v@0
      elseif item in k then
        v@( find item k )
      elseif atomic item then
        item
      else
        subs dict item
      endif }) expr
    endif
  endif }



% substitution tests;

cheq !( subs ("a 1) "a )      !( 1 );
cheq !( subs ("b 1) ("b "b))  !( 1 1 );
cheq !( subs ("c 1) ["c])     !( [1] );
cheq !( subs ("d 1) [] )      !( [] );

%breakin "subs;
cheq !( subs ("e [1]) "e )      !( [1] );
%breakin "subs;

cheq !( subs ("f [1]) ["f "f])  !( [[1][1]] );
cheq !( subs ("g 1) [1 ["g]]) !( [1 [1]] );

(cheq !( subs ("h 1 "i 2) ("h "i "h))
      !( 1 2 1 ))
(cheq !( subs ("j 1 "k 2) (["k]["j ["k] 3]))
      !( [2] [1 [2] 3] ))


% unification
% --------------------------------------------------;

id is pass;
intree is op x tree {x in (link leaf id tree)};
isvar is op x {
  if and[isphrase, not isconst] x
  then =[id, tolower] string x else o endif };


unify is op x y {
  if x = y then []
  elseif and[isvar x, not or[isvar y, x intree y]] then [ x, y ]
  elseif and[isvar y, not or[isvar x, y intree x]] then [ y, x ]
  elseif or[atomic x, atomic y, not match each tally x y] then "no
  else
    begin
      if (shape x) ~= (shape y) then "no
      else
        hu := unify (each head x y);
        if hu = "no then "no
        else
          tu := (unify (each ((hu subs) tail) x y));
          if tu = "no then "no
          else hu link tu endif
        endif
      endif
    end
  endif }


% unification tests;

% 0 variables;
cheq !( unify 0 0 )     !( [] );
cheq !( unify 0 1 )     !( "no );

% single variable;

cheq !( unify "a "a )     !( [] );

cheq !( unify "a ["x "a]) !( "no );
cheq !( unify "a 5 )      !( ["a, 5] );
cheq !( unify "a [] )     !( "a [] );
cheq !( unify "a [1] )    !( "a [1] );

cheq !( unify [ 1 "vs "a] [ 1 "vs 2]) !( "a 2 );
cheq !( unify [ 1 "vs  2] ["x "vs 2]) !( "x 1 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );

cheq !( unify ["a "a] [1 2]) !( "no );
cheq !( unify ["a "a] [1 1]) !( "a 1 );

cheq !( unify ["a ["a]] [1 [1]]) !( "a 1 );
cheq !( unify ["a "a] [[1] [1]]) !( "a [1] );


% logic symbols
% --------------------------------------------------;

show is op x {
  if isboolean x then
    result := if x then glyph "top else glyph "bot endif
  elseif isphrase x then
    result := if isconst x
      then glyph x
      else string x
    endif
  else
    result := link each string (link each show x)
  endif;
  link (each string result) }

% tests for 'show';

chk is op want tree {
  got := show tree;
  if want = got then ok
  else write link[ 'mismatch:', display [want, got]] endif }

chk '⊤' "top; chk '⊥' "bot;
chk '⊥⊥' oo; chk '⊤⊥' lo; % booloan literals;
chk '∀' "forall; chk '∃' "exists;
chk 'x' "x; chk 'Px' ("P "x);
chk '∀xPx' ["forall "x ["P "x]];


% predicate logic in nial
% --------------------------------------------------

ok := null;

reload is { loaddefs "fol };

head is first;

dump is op x { write display x };
check is op msg pred { if pred then ok else fault msg endif };

unquote is op q {
  link descan scan link descan deparse q };

chkev is op q {
  if eval q then ok
  else write 'failed: ' (unquote q) endif };

cheq is op q0 q1 {
  v0 v1 := each eval q0 q1;
  if v0 = v1 then ok
  else write (
     link 'failed: ' (unquote q0) ' : ' (display v0) ' != ' (display v1))
  endif };

words is op Str {
   % from towords.ndf in nial distro;
   Strings := EACH phrase ( `  match Str cut Str ) }


% logical language
% --------------------------------------------------

consts glyphs := cols mix [
  "forall '∀',
  "exists '∃',
  "top    '⊤',
  "bot    '⊥'
];

isconst is op k { k in consts };
glyph is op k { glyphs@( find k consts )};


% unification
% --------------------------------------------------

id is pass;
intree is op x tree {x in (link leaf id tree)};
isvar is op x {
  if and[isphrase, not isconst] x
  then =[id, tolower] string x else o endif };

unify is op x y {
  if x = y then []
  elseif and[isvar x, not or[isvar y, x intree y]] then [ x, y ]
  elseif and[isvar y, not or[isvar x, y intree x]] then [ y, x ]
  elseif or[atomic x, atomic y, not match each tally x y] then "no
  else
    begin
      if not (shape x) = (shape y) then break endif;
      sub := link eachboth unify x y;
      if "no intree sub then "no
      else filter ([] ~=) sub endif
    end
  endif }

chkev !( unify "a "a = [] );
chkev !( unify "a ["x "a] = "no );
chkev !( unify "a 5 = ["a, 5] );
cheq !( unify [ 1 "vs "a] [ 1 "vs 2]) !( "a 2 );
cheq !( unify [ 1 "vs  2] ["x "vs 2]) !( "x 1 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );


% logic symbols
% --------------------------------------------------

show is op x {
  if isboolean x then
    result := if x then glyph "top else glyph "bot endif
  elseif isphrase x then
    result := if isconst x
      then glyph x
      else string x
    endif
  else
    result := link each string (link each show x)
  endif;
  link (each string result) }


% test suite
% --------------------------------------------------

chk is op want tree {
  got := show tree;
  if want = got then ok
  else write link[ 'mismatch:', display [want, got]] endif }

chk '⊤' "top; chk '⊥' "bot;
chk '⊥⊥' oo; chk '⊤⊥' lo; % booloan literals;
chk '∀' "forall; chk '∃' "exists;
chk 'x' "x; chk 'Px' ("P "x);
chk '∀xPx' ["forall "x ["P "x]];


% predicate logic in nial


% helpers/ language tweaks
% --------------------------------------------------;

reload is { loaddefs "nialogic };

ok := null;

% renames and abbreviations;
id is pass;
ph is phrase;
head is first;
init is front;
tail is rest;

zip IS EACHBOTH link;
ints is tell;

% string tools;
words is op Str {
  % split string on space character;
  % (from towords.ndf in nial distro);
  Strings := EACH phrase ( `  match Str cut Str ) }

unquote is op q {
  % convert !( quoted expressions ) back to text;
  link descan scan link descan deparse q };

% glue a string together;
implode is op glue parts {
  link[head, link(glue eachright link tail)] parts }


% more helpers...;


% does any item in given array match predicate p?
% ex:  !(any atomic a b c d etc) -> are any of them atomic?;
any is tr p ( or EACH p);

% do all items in given array match predicate p?
% ex:  !( all isboolean ) <-> !( allbools );
all is tr p ( and EACH p);

% implication, like short circuiting 'and';
imp is tr f g op x (
  if f x then g x else o endif );

% hex digits;
hexits := '0123456789ABCDEF';

hexbyte is (op n { hexits#((floor (n div 16)) (n mod 16) )});

% remove nesting until a simple or non-solitary array;
% mostly to allow using [...] with fewer commas ;
unboxed is fork[and[1=tally, not simple],unboxed head,id];



% colored text
% --------------------------------------------------;
setwidth 1024; % fix overzealous line wrapping;

esc := char 27;
bold := link esc '[0;1m';
plain := link esc '[0m';
clrscr := link esc '[H' esc '[J';
newline := char 10;

xc is op color {
  % 256 xterm colors + mnemonics for first 16 ascii colors;
  if isinteger color then string color
  elseif isphrase color then xc (string color)
  elseif head color in 'krgybmcwKRGYBMCW'
    then string (head color find 'krgybmcwKRGYBMCW')
    else fault ['invalid color:', display color]
  endif };

fg is op color { link esc '[38;5;' (xc color)  'm' };
bg is op color { link esc '[48;5;' (xc color)  'm' };

cstr is op x {
  res := string x;
  if res = '||' then '|'
  elseif `| = head res then fg rest res
  else res endif };
emit is op a { writescreen (link each cstr) a };

colortest is {
  (each emit
     link rows
     each link rows (16 16 reshape)
     each (' ' link)
     each (link[fg,hexbyte]) (tell 256))
  null; % don't return a value; }

% a little logo:;
nialogic := "|B "nia "|C `l "|c "ogic "|w;

clear is { emit link Clrscr Nialogic ( char 10 ) }; clear;

hline is op x {link each string (x reshape) phrase '─'};
section is op x {
  emit "|b '── ' "|w x "|b ' ' (hline (50 -) tally x) "|w }


% test framework
% --------------------------------------------------;

try is op quote {
  oldtrigger := settrigger o;
  result := eval quote;
  settrigger oldtrigger;
  result }

cheq is op q0 q1 {
  res := each try q0 q1; msg := null;
  if isfault res then
    msg := (fg "y) 'error: ' (fg "R) (string res)
  elseif imp[= each tally, =] res then
    ok
  else
    v0 v1 := res;
    msg := ((newline) (fg "r) ' expected: ' (fg "M) (display v1)
            (newline) (fg "r) '  but saw: ' (fg "R) (display v0))
  endif;
  res := (fg "K) 'testing:' plain (unquote q0);
  if empty msg
    then res := res link ((fg "g) 'ok' plain)
    else res := res link ((fg "r) (link msg) plain)
  endif;
  emit res };


section 'substitution';
% --------------------------------------------------;

subs is op dict expr {
  if any empty dict expr then expr
  else
    k v := cols ((floor(tally dict /2) 2) reshape dict);
    if expr in k then v@( find expr k )
    else each (op item {
      if k = solitary item then
        v@0
      elseif item in k then
        v@( find item k )
      elseif atomic item then
        item
      else
        subs dict item
      endif }) expr
    endif
  endif }



% substitution tests;
% --------------------------------------------------;

cheq !( subs ("a 1) "a )      !( 1 );
cheq !( subs ("b 1) ("b "b))  !( 1 1 );
cheq !( subs ("c 1) ["c])     !( [1] );
cheq !( subs ("d 1) [] )      !( [] );

%breakin "subs;
cheq !( subs ("e [1]) "e )      !( [1] );
%breakin "subs;

cheq !( subs ("f [1]) ["f "f])  !( [[1][1]] );
cheq !( subs ("g 1) [1 ["g]]) !( [1 [1]] );

(cheq !( subs ("h 1 "i 2) ("h "i "h))
      !( 1 2 1 ))
(cheq !( subs ("j 1 "k 2) (["k]["j ["k] 3]))
      !( [2] [1 [2] 3] ))


section 'unification';
% --------------------------------------------------;

id is pass;
intree is op x tree {x in (link leaf id tree)};
isvar is imp[isphrase, `$ = head string ];

passive is link team [reverse,pass][2 take,2 drop];

con is tr f (f link team[reverse,pass][2 take,2 drop]);

lengths is each tally;

unify is op x y {
  if x = y then []
  elseif and[isvar x, not or[isvar y, x intree y]] then [ x, y ]
  elseif and[isvar y, not or[isvar x, y intree x]] then [ y, x ]
  elseif or[atomic x, atomic y, diverse lengths x y] then "no
  elseif (shape x) ~= (shape y) then "no
  else hu := unify (each head x y);
    if hu = "no then "no
    else
      tu := (unify (each ((hu subs) tail) x y));
      if tu = "no then "no
      else hu link tu endif
    endif
  endif }


% unification tests;
%---------------------------------------------------;

cheq !( isvar "a )      !( o );
cheq !( isvar "$a )     !( l );

% 0 variables;
cheq !( unify 0 0 )     !( [] );
cheq !( unify 0 1 )     !( "no );

% single variable;

cheq !( unify "$a "$a )     !( [] );

cheq !( unify "$a ["x "$a]) !( "no );
cheq !( unify "$a 5 )      !( ["$a, 5] );
cheq !( unify "$a [] )     !( "$a [] );
cheq !( unify "$a [1] )    !( "$a [1] );

cheq !( unify "$a "a )    !( "$a "a );

cheq !( unify [ 1 "vs "$a] [  1 "vs 2]) !( "$a 2 );
cheq !( unify [ 1 "vs   2] ["$x "vs 2]) !( "$x 1 );
cheq !( unify [ 1 "vs "$a] ["$x "vs 2]) !( "$x 1 "$a 2 );
cheq !( unify [ 1 "vs "$a] ["$x "vs 2]) !( "$x 1 "$a 2 );

cheq !( unify ["$a "$a] [1 2]) !( "no );
cheq !( unify ["$a "$a] [1 1]) !( "a 1 );

cheq !( unify ["$a ["$a]] [1 [1]]) !( "$a 1 );
cheq !( unify ["$a "$a] [[1] [1]]) !( "$a [1] );



section 'tabular binary relations';
% --------------------------------------------------;

doma IS BYROWS first;  % first column is the domain;
codo IS BYROWS last;   % second column is the codomain;
iv IS BYROWS reverse;  % inverse;
body is last;

col is op n xs (floor(tally xs div n) link n reshape xs);
% law : ∀x:rel2[ 2 col link zip [doma, codo] x = x ] ;
% (where rel2 is a 2-column relational  ;


colget is op ab k { a b := ab; b@( find k a )};

% relate treats the table as an operation, and applies it to arguments;
relate is op rel vals {
  link sublist[or(vals eachleft eachright in each (0 pick)),
               each rest] (last rel) };

% total makes any dyad total (by falling back to 'id' if the dyad fails);
total is tr f op x {
  fx := try !( f x );
  if or[isfault,empty] fx then x else fx endif };


haskey is op rel key { key in   head rel };
keypos is op rel key { key find head rel };

showrel is op rel {
   if tally head rel <= 1
     then post[head, post last] rel
     else post[head, mix last] rel
   endif };


% relational algebra;

rename is op rel oldnew { old new := oldnew; [old new subs head, body] rel };

select is op rel keys {
 ind := rel eachright keypos keys;
 [ind choose head, cull (ind eachright choose body)] rel };

where is op rel keyvals {
  res := rel;
  for kv with rows (2 col keyvals) do
    key val := kv; ind := res keypos key;
    res := [head, sublist[each((val =)(ind pick)), id] last] res
  endfor; res };




% relational algebra tests;

ab := [ "a "b, [ "a1 "b1, "a2 "b2 ]];
cheq  !( ab rename "a "AA ) !( ["AA "b] [ "a1 "b1, "a2 "b2 ]);

cheq  !( ab select "a )     !( ["a]     [ "a1, "a2 ] );
cheq  !( ab select "b )     !( ["b]     [ "b1, "b2 ] );

% okay (for now?) to select the same column twice;
cheq  !( ab select "b "b)   !( ["b "b] [ "b1 "b1, "b2 "b2 ]);

% but rows should be unique;
bc := [ "b "c, [ "b3 "c1, "b2 "c1, "b1 "c2 ]];
cheq  !( bc select "c )  !( "c [ "c1, "c2 ] );
cheq  !( bc select "b )  !( "b [ "b3, "b2, "b1 ] );

cd := [ "c "d, [ "c1 "d1, "c2 "d2, "c3 "d1 ]];
cheq !( cd where "d "d1 ) !( [ "c "d ] [ "c1 "d1, "c3 "d1 ]);
cheq !( cd where "d "d1 "c "c1 ) !( [ "c "d ] [ "c1 "d1 ]);




section 'logical language';
% --------------------------------------------------;

master := [
  "const    "alias   "glyph  "synid,
[ "top       "l      (ph'⊤')  "const,
  "bot       "o      (ph'⊥')  "const,
  "forall    "A.     (ph'∀')  "quant,
  "exists    "E.     (ph'∃')  "quant,
  "entails   "|-     (ph'⊢')  "infix,
  "implies   "->     (ph'⇒')  "infix,
  "iff       "><     (ph'⇔')  "infix,
  "and       "*.     (ph'∧')  "infix,
  "vel       "+.     (ph'∨')  "infix,
  "not       "-.     (ph'¬')  "monad,
  "xor       "~:     (ph'⊕')  "infix,
  "reduce    "/.     (ph'/')  "trans,
  "gamma     "G.     (ph'Γ')  "const,
  "delta     "D.     (ph'Δ')  "const,
  "sub       "sub    (ph'⊂')  "infix,
  "sbe       "sbe    (ph'⊆')  "infix,
  "lambda    "lam    (ph'λ')  "quant,
  "rarrow    "rarr   (ph'→')  "infix,
  "LPAREN    (ph'(') (ph'(')  "token,
  "RPAREN    (ph')') (ph')')  "token,
  "LBRACK    (ph'[') (ph']')  "token,
  "RBRACK    (ph'[') (ph']')  "token,
  "LBRACE    (ph'{') (ph'{')  "token,
  "RBRACE    (ph'}') (ph'}')  "token
]];

syntax := [ "synid   "fields     "rule,
[ "const   ([])         ("^),
  "quant   ("$v+ "$p+)  ("^ "$v+ (ph'[') "$p+ (ph']')),
  "infix   ("$p "$q)    ("$p "^ "$q),
  "trans   ("$c "$p+)   ("$c "^ "$p+),
  "monad   ("$p)        ("^ "$p)
]];

GlyphView IS { Master select "const "glyph };
glyph IS TOTAL ( GlyphView relate );

cheq !( (master select "alias "glyph) relate "A. "E. ) !( words '∀ ∃' );
cheq !( glyph "A. "x "E. "y ) !( words '∀ x ∃ y' );


% rendering for logic language;
% --------------------------------------------------;

gentoks is op node {
  node := unboxed node;
  sym := head node;
  rule := (Syntax relate)({ Master select "const "synid } relate) sym;
  if empty rule then
    % it wasn't in the table so it must be a variable or predicate;
    if empty rest node then string sym
    else sym '(' link (each gentoks) (rest node) ')' endif
  else
    ptn tpl := rule;
    if "no = (u := unify ptn (rest node)) then
      fault link ['?unify: failed to unify pattern: ',
                   (display ptn), ' against rest: ',
                   (display rest node) ]
    else g := glyph sym;  u := ["^, glyph sym] link u;
      each gentoks (subs u tpl)
    endif
  endif };

fmt is op node { link each string content gentoks node };

% tests for language display
% --------------------------------------------------;

%cheq !( each fmt "top "bot "forall "exists "x ) !( '⊤' '⊥' '∀' '∃' 'x' );
cheq !( fmt ("P "x))                             !( 'P(x)' );
cheq !( fmt  "forall ["x] ["P "x]  )             !( '∀x[P(x)]' );
cheq !( fmt ["forall "x ["implies "x "top]])     !( '∀x(x⇒⊤)'  );


section 'bitvars (truth tables)';
% --------------------------------------------------;

bitvars is OP N {
  rows (1 match transpose BYROWS 0 laminate list tell ( N reshape 2 )) }


cheq !( bitvars 3 ) !([oooollll,oollooll,olololol]);




section 'ZF (Zermelo-Fraenkel set theory)';
% --------------------------------------------------;

zf := [ "rulename "note "wff,
[ "zf.extensionality
     'Sets with the same members are equal.'
     '∀(A,B,x)[(X ∈ A ⇔ X ∈ B) ⇒ (A = B)].',
  "zf.foundation
     'Every non-empty set contains an element distinct from itself.'
     '∀S[(∃x.x∈S) ⇒ ∃y∈S[∀z∈S[ ¬(z∈y)]]].',
  "zf.pairing
     'For any pair of sets, there is a set containing exactly that pair.'
     '∀A ∀B ∃C ∀y[y∈C ⇔ (y=A ∨ y=B)].',
  "zf.infinity
     'There exists an infinite set.'
     '∃S[ ∅∈S ∧ ∀x∈S[ X∪X⁺ ∈ S ]].',
  "zf.union
     'For any two sets, there is a set equal to their union.'
     '∀X ∃Y ∀u[u∈Y ⇔ ∃z. (z∈X ∧ u∈z)].',
  "zf.powerset
     'The powerset of set X contains every subset of X.'
     '∀X ∃Y ∀u [ u∈Y ⇔ u⊆X ].',
  "zf.existence
     'There exists an empty set.'
     '∃S ∀X[¬(X∈S)].',
  "zf.separation
     'Predicate functions can partition a set.'
     '∀P:(a → Bit)[∀z∃x∀y(y∈x ⇒ (y∈z ∧ P(y)))].',
  "zf.replacement
     'The image of a set under a function is also a set.'
     '∃x.∀y∈a[ ∃z.A(y,z) ⇒ ∃z∈x.A(y,z) ]' ]];

% abstract syntax trees for zf (for testing the parser);

zf_ast := [ "rulename "ast, [
  "zf.extensionality
      ["forall ["A "B "X]
          ["imp ["iff ["mem "X "A] ["mem "X "B]] ["eql "A "B]]],
  "zf.powerset
      ["forall ["X] ["exists ["Y] ["forall ["u]
          ["iff ["mem "u "Y] ["sbe "u "y]]]]],
  "zf.existence
      ["exists ["S] ["forall ["X]
          ["not ["mem "X "S]]]],
  "zf.separation
      ["schema ["P ["mem "P ["fun "$a "bit]]]
          ["forall ["Z "Y] ["exists ["X]
              ["imp ["mem "Y "X] ["and ["mem "Y "Z] ["P "y]]]]]],
  "zf.replacement ["schema ["A "z]
      "TODO],
  "zf.foundation
      ["forall ["S]
          ["imp ["exists ["X ["mem "X "S]]
             ["exists ["Y ["mem "Y "S] ["forall ["Z ["mem "Z "S]]
               ["not ["mem "Z "Y]]]]]]]],
  "zf.pairing
      ["forall ["A "B] ["exists ["C]  ["forall ["Y]
          ["iff ["mem "Y "C] ["vel ["eq "Y "A] ["eq "Y "B ]]]]]],
  "zf.infinity
      ["exists ["S]
        ["and ["mem "nil "S]
              ["forall [["X ["mem "X "S]]]
                       ["mem ["union "X ["set "X]] "S]]]],
  "zf.union
     ["forall ["X] ["exists ["Y] ["forall "u]
       ["iff ["mem "u "Y]
             ["exists ["Z] ["and ["mem "Z "X] ["mem "U "Z]]]]]] ]];

section 'command prompt';
% --------------------------------------------------;

stack := []

bar := link ' ' (fg "K) '|' (fg "w) ' '

push is op x {
  nonlocal stack; stack := stack link x }

pop is op x {
  nonlocal stack; res stack := [last, front] stack; res }

prompt is { readscreen link (fg "r) ' > ' (fg "w) };

repl is {
  done := false;
  repeat line := prompt;
    for cmd with each phrase (words line) do
      if cmd = "bye then done := true
      else push cmd endif
    endfor
  until done endrepeat };

# repl

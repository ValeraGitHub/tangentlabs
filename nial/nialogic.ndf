% predicate logic in nial


% helpers/ language tweaks
% --------------------------------------------------;
ok := null;

reload is { loaddefs "nialogic };

head is first;
tail is rest;
zip IS EACHBOTH link;
ints is tell;

dump is op x { write display x };
check is op msg pred { if pred then ok else fault msg endif };

words is op Str {
  % split string on space character;
  % (from towords.ndf in nial distro);
  Strings := EACH phrase ( `  match Str cut Str ) }

unquote is op q {
  % convert !( quoted expressions ) back to text;
  link descan scan link descan deparse q };

% does any item in an array match the predicate?
% ex:  !(any atomic a b c d etc) -> are any of them atomic?;
any is tr p (or EACH p);
all is tr p (and EACH p);

% glue a string together;
implode is op glue parts {
  link[head, link(glue eachright link tail)] parts }

% 'imp' as short circuit boolean 'and';
imp is tr f g op x ( if f x then g x else o endif );

hexits := '0123456789ABCDEF';

hexbyte is (op n { hexits#((floor (n div 16)) (n mod 16) )});

% colored text
% --------------------------------------------------;
setwidth 1024; % fix overzealous line wrapping;

esc := char 27;
bold := link esc '[0;1m';
plain := link esc '[0m';
clrscr := link esc '[H' esc '[J';
newline := char 10;

xc is op color {
  % 256 xterm colors + mnemonics for first 16 ascii colors;
  if isinteger color then string color
  elseif isphrase color then xc (string color)
  elseif head color in 'krgybmcwKRGYBMCW'
    then string (head color find 'krgybmcwKRGYBMCW')
    else fault ['invalid color:', display color]
  endif };

fg is op color { link esc '[38;5;' (xc color)  'm' };
bg is op color { link esc '[48;5;' (xc color)  'm' };

cstr is op x {
  res := string x;
  if res = '||' then '|'
  elseif `| = head res then fg rest res
  else res endif };
emit is op a { writescreen (link each cstr) a };

colortest is {
  (each emit
     link rows
     each link rows (16 16 reshape)
     each (' ' link)
     each (link[fg,hexbyte]) (tell 256))
  null; % don't return a value; }

% a little logo:;
nialogic := "|B "nia "|C `l "|c "ogic "|w;

clear is { emit link Clrscr Nialogic ( char 10 ) }; clear;

hline is op x {link each string (x reshape) phrase '─'};
section is op x { emit "|b '── ' "|w x "|b ' ' (hline (50 -) tally x) "|w }


% test framework
% --------------------------------------------------;

try is op quote {
  oldtrigger := settrigger o;
  result := eval quote;
  settrigger oldtrigger;
  result }

cheq is op q0 q1 {
  res := each try q0 q1; msg := null;
  if isfault res then
    msg := (fg "y) 'error: ' (fg "R) (string res)
  elseif imp[= each tally, match] res then
    ok
  else
    v0 v1 := res;
    msg := ((newline) (fg "r) ' expected: ' (fg "M) (display v1)
            (newline) (fg "r) '  but saw: ' (fg "R) (display v0))
  endif;
  res := (fg "K) 'testing:' plain (unquote q0);
  if empty msg
    then res := res link ((fg "g) 'ok' plain)
    else res := res link ((fg "r) (link msg) plain)
  endif;
  emit res };


section 'substitution';
% --------------------------------------------------;

subs is op dict expr {
  if any empty dict expr then expr
  else
    k v := cols ((floor(tally dict /2) 2) reshape dict);
    if expr in k then v@( find expr k )
    else each (op item {
      if k = solitary item then
        v@0
      elseif item in k then
        v@( find item k )
      elseif atomic item then
        item
      else
        subs dict item
      endif }) expr
    endif
  endif }



% substitution tests;
% --------------------------------------------------;

cheq !( subs ("a 1) "a )      !( 1 );
cheq !( subs ("b 1) ("b "b))  !( 1 1 );
cheq !( subs ("c 1) ["c])     !( [1] );
cheq !( subs ("d 1) [] )      !( [] );

%breakin "subs;
cheq !( subs ("e [1]) "e )      !( [1] );
%breakin "subs;

cheq !( subs ("f [1]) ["f "f])  !( [[1][1]] );
cheq !( subs ("g 1) [1 ["g]]) !( [1 [1]] );

(cheq !( subs ("h 1 "i 2) ("h "i "h))
      !( 1 2 1 ))
(cheq !( subs ("j 1 "k 2) (["k]["j ["k] 3]))
      !( [2] [1 [2] 3] ))


section 'unification';
% --------------------------------------------------;

id is pass;
intree is op x tree {x in (link leaf id tree)};
isvar is op x {
  if and[isphrase, ("$ ~=)] x
  then =[id, tolower] string x else o endif };

passive is link team [reverse,pass][2 take,2 drop];

con is tr f (f link team[reverse,pass][2 take,2 drop]);

lengths is each tally;

unify is op x y {
  if x = y then []
  elseif x = "_ then [ "_, y ]
  elseif x = "$ and isvar y then [ "$, y ]
  elseif and[isvar x, not or[isvar y, x intree y]] then [ x, y ]
  elseif and[isvar y, not or[isvar x, y intree x]] then [ y, x ]
  elseif or[atomic x, atomic y, diverse lengths x y] then "no
  elseif (shape x) ~= (shape y) then "no
  else hu := unify (each head x y);
    if hu = "no then "no
    else
      tu := (unify (each ((hu subs) tail) x y));
      if tu = "no then "no
      else hu link tu endif
    endif
  endif }


% unification tests;
%---------------------------------------------------;

% 0 variables;
cheq !( unify 0 0 )     !( [] );
cheq !( unify 0 1 )     !( "no );

% single variable;

cheq !( unify "a "a )     !( [] );

cheq !( unify "a ["x "a]) !( "no );
cheq !( unify "a 5 )      !( ["a, 5] );
cheq !( unify "a [] )     !( "a [] );
cheq !( unify "a [1] )    !( "a [1] );

cheq !( unify [ 1 "vs "a] [ 1 "vs 2]) !( "a 2 );
cheq !( unify [ 1 "vs  2] ["x "vs 2]) !( "x 1 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );

cheq !( unify ["a "a] [1 2]) !( "no );
cheq !( unify ["a "a] [1 1]) !( "a 1 );

cheq !( unify ["a ["a]] [1 [1]]) !( "a 1 );
cheq !( unify ["a "a] [[1] [1]]) !( "a [1] );



section 'tabular binary relations';
% --------------------------------------------------;

doma IS BYROWS first;  % first column is the domain;
codo IS BYROWS last;   % second column is the codomain;
iv IS BYROWS reverse;  % inverse;
body is last;

col is op n xs (floor(tally xs div n) link n reshape xs);
% law : ∀x:rel2[ 2 col link zip [doma, codo] x = x ] ;
% (where rel2 is a 2-column relational  ;


colget is op ab k { a b := ab; b@( find k a )};

% relate treats the table as an operation, and applies it to arguments;
relate is op rel vals {
  link sublist[or(vals eachleft eachright in each (0 pick)),
               each rest] (last rel) };

haskey is op rel key { key in   head rel };
keypos is op rel key { key find head rel };

showrel is op rel {
   if tally head rel <= 1
     then post[head, post last] rel
     else post[head, mix last] rel
   endif };

% relational algebra;

rename is op rel oldnew { old new := oldnew; [old new subs head, body] rel };

select is op rel keys {
 ind := rel eachright keypos keys;
 [ind choose head, cull (ind eachright choose body)] rel };

where is op rel keyvals {
  res := rel;
  for kv with rows (2 col keyvals) do
    key val := kv; ind := res keypos key;
    res := [head, sublist[each((val =)(ind pick)), id] last] res
  endfor; res };




% relational algebra tests;

ab := [ "a "b, [ "a1 "b1, "a2 "b2 ]];
cheq  !( ab rename "a "AA ) !( ["AA "b] [ "a1 "b1, "a2 "b2 ]);

cheq  !( ab select "a )     !( ["a]     [ "a1, "a2 ] );
cheq  !( ab select "b )     !( ["b]     [ "b1, "b2 ] );

% okay (for now?) to select the same column twice;
cheq  !( ab select "b "b)   !( ["b "b] [ "b1 "b1, "b2 "b2 ]);

% but rows should be unique;
bc := [ "b "c, [ "b3 "c1, "b2 "c1, "b1 "c2 ]];
cheq  !( bc select "c )  !( "c [ "c1, "c2 ] );
cheq  !( bc select "b )  !( "b [ "b3, "b2, "b1 ] );

cd := [ "c "d, [ "c1 "d1, "c2 "d2, "c3 "d1 ]];
cheq !( cd where "d "d1 ) !( [ "c "d ] [ "c1 "d1, "c3 "d1 ]);
cheq !( cd where "d "d1 "c "c1 ) !( [ "c "d ] [ "c1 "d1 ]);




section 'logical language';
% --------------------------------------------------;

ph is phrase;

master := [
  "const    "alias   "glyph  "synid,
[ "top       "l      (ph'⊤')  "const,
  "bot       "o      (ph'⊥')  "const,
  "forall    "A.     (ph'∀')  "quant,
  "exists    "E.     (ph'∃')  "quant,
  "implies   "->     (ph'⇒')  "infix,
  "iff       "><     (ph'⇔')  "infix,
  "and       "*.     (ph'∧')  "infix,
  "vel       "+.     (ph'∨')  "infix,
  "not       "-.     (ph'¬')  "monad,
  "xor       "~:     (ph'⊕')  "infix,
  "reduce    "/.     (ph'/')  "trans,
  "gamma     "G.     (ph'Γ')  "const,
  "delta     "D.     (ph'Δ')  "const,
  "sub       "sub    (ph'⊂')  "infix,
  "sbe       "sbe    (ph'⊆')  "infix,
  "LPAREN    (ph'(') (ph'(')  "token,
  "RPAREN    (ph')') (ph')')  "token
]];

% TODO: normalize syntax table;
syntax := [
  "synid   "fields     "rule,
[ "const   [[]]        ("^),
  "quant   ("v+ "p+)   ("^ "v+ (ph'(') "p+ (ph')')),
  "infix   ("p "q)     ("p "^ "q),
  "trans   ("o "p+)    ("o "^ "p),
  "monad   ("p)        ("^ "p)
]];


consts alias glyphs synrule := (cols mix) last master;
glyphs := each phrase glyphs;

isconst is op k { k in consts };
glyph is op k { glyphs@( find k consts )};

cheq !( (master select "alias "glyph) relate "A. "E. ) !( words '∀ ∃' );


% rendering for logic language;
% --------------------------------------------------;

show is op x {
  if isboolean x then
    result := if x then glyph "top else glyph "bot endif
  elseif isphrase x then
    result := if isconst x
      then glyph x
      else string x
    endif
  else
    result := link each string (link each show x)
  endif;
  link (each string result) }


templates := mix [
  ("top)           ((glyph "top)),
  ("bot)           ((glyph "bot)),
  ("forall "$ "_)  ((glyph "forall) "$ '(' "_ ')'),
  ("exists "$ "_)  ((glyph "exists) "$ '(' "_ ')'),
  ("$ "implies "_) ("$ (glyph "implies) "_)
];

fmt is op node {
  i found := 0 o; result := null;
  while i < tally rows templates and not found do
    ptn tpl := templates#((i 0) (i 1));
    if "no = (u := unify ptn node) then ok
    else found := o;
      result := each (op x {
        if isconst x then glyph x
        elseif atomic x then x
        else link fmt x endif }) (subs u tpl)
    endif;
    i := i + 1;
  endwhile;
  if empty result then node else link each string result endif };


% tests for "show"
%-----------------------;

chk is op want tree {
  got := show tree;
  if got = string want then ok
  else write link[ 'mismatch:', display [want, got]] endif }

chk '⊤' "top; chk '⊥' "bot;
chk '⊥⊥' oo; chk '⊤⊥' lo; % booloan literals;
chk '∀' "forall; chk '∃' "exists;
chk 'x' "x; chk 'Px' ("P "x);
chk '∀xPx' ["forall "x ["P "x]];

cheq !( '∀x(x⇒⊤)' ) !( fmt ("forall "x ("x "implies "top)));



section 'bitvars (truth tables)';
% --------------------------------------------------;

bitvars is OP N {
  rows (1 match transpose BYROWS 0 laminate list tell ( N reshape 2 )) }


cheq !( bitvars 3 ) !([oooollll,oollooll,olololol]);




section 'ZF (Zermelo-Fraenkel set theory)';
% --------------------------------------------------;

zf := [
  ("zf.extension
     'Sets with the same members are equal.'
     '∀A ∀B ∀X [(X ∈ A ⇔ X ∈ B) ⇒ (A = B)].'
     ["forall ["A "B "X]
        ["imp ["iff ["mem "X "A] ["mem "X "B]]
              ["eql "A "B]]]
  ),
  ("zf.foundation
     'Every non-empty set contains an element distinct from itself.'
     '∀S[(∃x.x∈S) ⇒ ∃y∈S[∀z∈S[ ¬(z∈y)]]].'
     ["forall ["S]
       ["imp ["exists ["X ["mem "X "S]]
             ["exists ["Y ["mem "Y "S] ["forall ["Z ["mem "Z "S]]
               ["not ["mem "Z "Y]]]]]]]]
  ),
  ("zf.pairing
     'For any pair of sets sets, there is a set containing exactly that pair.'
     '∀A ∀B ∃C ∀y[y∈C ⇔ (y=A ∨ y=B)].'
     ["forall ["A "B] ["exists ["C]  ["forall ["Y]
       ["iff ["mem "Y "C]
             ["vel ["eq "Y "A] ["eq "Y "B ]]]]]]
  ),
  ("zf.infinity
     '(There exists an infinite set.)'
     '∃S[ \empty∈S ∧ (∀x ∈ S)[ X∪{X} ∈ S ]].'
     ["exists ["S]
        ["and ["mem "nil "S]
              ["forall [["X ["mem "X "S]]]
                       ["mem ["union "X ["set "X]]
                             "S]]]]
  ),
  ("zf.union
     'For any sets X and Y, there''s a set containing the union of X and Y.'
     '∀X ∃Y ∀u[u∈Y ⇔ ∃z. (z∈X ∧ u∈z)].'
     ["forall ["X] ["exists ["Y] ["forall "u]
       ["iff ["mem "u "Y]
             ["exists ["Z] ["and ["mem "Z "X] ["mem "U "Z]]]]]]
  ) ];



% zf, continued;

zf := zf link [
  ("zf.powerset
     'The powerset of set X contains every subset of X.'
     '∀X ∃Y ∀u [ u∈Y ⇔ u⊆X ].'
     ["forall ["X] ["exists ["Y] ["forall ["u]
       ["iff ["mem "u "Y] ["sbe "u "y]]]]]
  ),
  ("zf.existence
     'There exists an empty set.'
     '∃S ∀X[¬(X∈S)].'
     ["exists ["S] ["forall ["X]
       ["not ["mem "X "S]]]]
  ),
  ("zf.separation
     'Predicate functions can partition a set.'
     '∀P∈(a → Bit)[∀z∃x∀y(y∈x ⇒ (y∈z ∧ P(y)))].'
     ["schema ["P ["mem "P ["fun "$a "bit]]]
       ["forall ["Z "Y] ["exists ["X]
          ["imp ["mem "Y "X]
                ["and ["mem "Y "Z] ["P "y]]]]]]
  ),
  ("zf.replacement
     'Functions map sets onto sets.'
     ''
     ["schema ["F]
       ["imp ["forall ["X "Y "Z]
               ["imp ["and ["F "X "Y "p] ["F "X "Z "p]]
                 ["eql "Y "Z]]]
             ["forall ["X "Y "y]
               ["iff ["mem "y "Y]
                     ["exists ["x ["mem "x "X]]
                        ["F "x "y "p]]]]]]
  ) ];

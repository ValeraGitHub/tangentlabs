% predicate logic in nial


% helpers/ language tweaks
% --------------------------------------------------;
ok := null;

reload is { loaddefs "nialogic };

head is first;
tail is rest;
zip IS EACHBOTH link;
ints is tell;

dump is op x { write display x };
check is op msg pred { if pred then ok else fault msg endif };

words is op Str {
  % split string on space character;
  % (from towords.ndf in nial distro);
  Strings := EACH phrase ( `  match Str cut Str ) }

unquote is op q {
  % convert !( quoted expressions ) back to text;
  link descan scan link descan deparse q };

% does any item in an array match the predicate?
% ex:  !(any atomic a b c d etc) -> are any of them atomic?;
any is tr p (or EACH p);
all is tr p (and EACH p);

% glue a string together;
implode is op glue parts {
  link[head, link(glue eachright link tail)] parts }


hexits := '0123456789ABCDEF';

hexbyte is (op n { hexits#((floor (n div 16)) (n mod 16) )});

% colored text
% --------------------------------------------------;
setwidth 1024; % fix overzealous line wrapping;

esc := char 27;
bold := link esc '[0;1m';
plain := link esc '[0m';

emit is op a { writescreen (link each string) a };
clrscr is { link esc '[H' esc '[J' };
newline is { char 10 };

xc is op color {
  % 256 xterm colors + mnemonics for first 16 ascii colors;
  if isinteger color then string color
  elseif isphrase color then xc (string color)
  elseif head color in 'krgybmcwKRGYBMCW'
    then string (head color find 'krgybmcwKRGYBMCW')
    else fault ['invalid color:', display color]
  endif };

fg is op color { link esc '[38;5;' (xc color)  'm' };
bg is op color { link esc '[48;5;' (xc color)  'm' };


colortest is {
  (each emit
     link rows
     each link rows (16 16 reshape)
     each (' ' link)
     each (link[fg,hexbyte]) (tell 256))
  null; % don't return a value; }

% a little logo: ;
emit (nialogic := (fg "B) "nia (fg "C) `l (fg "c) "ogic (fg "w))

% test framework
% --------------------------------------------------;

try is op quotes {
  oldtrigger := settrigger o;
  result := null;
  for q with quotes do
    if isfault result then ok
    else qres := eval q;
      if isfault qres
        then result := qres
        else result := result link [qres]
      endif
    endif
  endfor;
  settrigger oldtrigger;
  result }

cheq is op q0 q1 {
  res := try q0 q1; msg := null;
  if isfault res then
    msg := (fg "y) 'error: ' (fg "R) (string res)
  elseif match res then
    ok
  else
    v0 v1 := res;
    msg := ((newline) (fg "r) ' expected: ' (fg "M) (display v0)
            (newline) (fg "r) '  but saw: ' (fg "R) (display v1))
  endif;
  res := (fg "K) 'testing:' plain (unquote q0);
  if empty msg
    then res := res link ((fg "g) 'ok' plain)
    else res := res link ((fg "r) (link msg) plain)
  endif;
  emit res };


% logical language
% --------------------------------------------------;

consts glyphs asciis := cols mix [
  "forall  '∀' '@',
  "exists  '∃' '#',
  "top     '⊤' '1',
  "bot     '⊥' '0',
  "implies '⇒' '}',
  "iff     '⇔' '=',
  "and     '∧' '*',
  "vel     '∨' '+',
  "not     '¬' '~',
  "xor     '⊕' '%',
  "reduce  '/' '/'
 ];


# TODO: merge record layout rules into above table
layout := [
  "top,
  "bot,
  "rel "$r "$t*,
  "and "$p "$q+,
  "vel "$p "$q+,
  "imp "$p "$q+,
  "iff "$p "$q+,
  "not "$p,
  "forall "$v+ "$p,
  "exists "$v+ "$p,
  "schema "$r+,
  "eq    "$x "$y+,
  "mem   "$x "$y+,
  "sub   "$x "$y,
  "sbe   "$x "$y
 ];

isconst is op k { k in consts };
glyph is op k { glyphs@( find k consts )};
ascii is op k { asciis@( find k consts )};

specials:= "" "` "~ "! "@  "$ "^ "& "* ". "| "+ "* ". ": "= "/ "? "- "_ "% "';






% substitution
% --------------------------------------------------;

subs is op dict expr {
  if any empty dict expr then expr
  else
    k v := cols ((floor(tally dict /2) 2) reshape dict);
    if expr in k then v@( find expr k )
    else each (op item {
      if k = solitary item then
        v@0
      elseif item in k then
        v@( find item k )
      elseif atomic item then
        item
      else
        subs dict item
      endif }) expr
    endif
  endif }



% substitution tests;

cheq !( subs ("a 1) "a )      !( 1 );
cheq !( subs ("b 1) ("b "b))  !( 1 1 );
cheq !( subs ("c 1) ["c])     !( [1] );
cheq !( subs ("d 1) [] )      !( [] );

%breakin "subs;
cheq !( subs ("e [1]) "e )      !( [1] );
%breakin "subs;

cheq !( subs ("f [1]) ["f "f])  !( [[1][1]] );
cheq !( subs ("g 1) [1 ["g]]) !( [1 [1]] );

(cheq !( subs ("h 1 "i 2) ("h "i "h))
      !( 1 2 1 ))
(cheq !( subs ("j 1 "k 2) (["k]["j ["k] 3]))
      !( [2] [1 [2] 3] ))


% unification
% --------------------------------------------------;

id is pass;
intree is op x tree {x in (link leaf id tree)};
isvar is op x {
  if and[isphrase, not isconst, ("$ ~=)] x
  then =[id, tolower] string x else o endif };

passive is link team [reverse,pass][2 take,2 drop];

con is tr f (f link team[reverse,pass][2 take,2 drop]);

lengths is each tally;

unify is op x y {
  if x = y then []
  elseif x = "_ then [ "_, y ]
  elseif x = "$ and isvar y then [ "$, y ]
  elseif and[isvar x, not or[isvar y, x intree y]] then [ x, y ]
  elseif and[isvar y, not or[isvar x, y intree x]] then [ y, x ]
  elseif or[atomic x, atomic y, diverse lengths x y] then "no
  elseif (shape x) ~= (shape y) then "no
  else hu := unify (each head x y);
    if hu = "no then "no
    else
      tu := (unify (each ((hu subs) tail) x y));
      if tu = "no then "no
      else hu link tu endif
    endif
  endif }


% unification tests;

% 0 variables;
cheq !( unify 0 0 )     !( [] );
cheq !( unify 0 1 )     !( "no );

% single variable;

cheq !( unify "a "a )     !( [] );

cheq !( unify "a ["x "a]) !( "no );
cheq !( unify "a 5 )      !( ["a, 5] );
cheq !( unify "a [] )     !( "a [] );
cheq !( unify "a [1] )    !( "a [1] );

cheq !( unify [ 1 "vs "a] [ 1 "vs 2]) !( "a 2 );
cheq !( unify [ 1 "vs  2] ["x "vs 2]) !( "x 1 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );
cheq !( unify [ 1 "vs "a] ["x "vs 2]) !( "x 1 "a 2 );

cheq !( unify ["a "a] [1 2]) !( "no );
cheq !( unify ["a "a] [1 1]) !( "a 1 );

cheq !( unify ["a ["a]] [1 [1]]) !( "a 1 );
cheq !( unify ["a "a] [[1] [1]]) !( "a [1] );


% logic symbols
% --------------------------------------------------;

show is op x {
  if isboolean x then
    result := if x then glyph "top else glyph "bot endif
  elseif isphrase x then
    result := if isconst x
      then glyph x
      else string x
    endif
  else
    result := link each string (link each show x)
  endif;
  link (each string result) }




% tests for 'show';

chk is op want tree {
  got := show tree;
  if want = got then ok
  else write link[ 'mismatch:', display [want, got]] endif }

chk '⊤' "top; chk '⊥' "bot;
chk '⊥⊥' oo; chk '⊤⊥' lo; % booloan literals;
chk '∀' "forall; chk '∃' "exists;
chk 'x' "x; chk 'Px' ("P "x);
chk '∀xPx' ["forall "x ["P "x]];


% rule-based printer
% --------------------------------------------------;

templates := mix [
  ("forall "$ "_)  ((glyph "forall) "$ '(' "_ ')'),
  ("exists "$ "_)  ((glyph "exists) "$ '(' "_ ')'),
  ("$ "implies "_) ("$ (glyph "implies) "_)
];

fmt is op node {
  i found := 0 o; result := null;
  while i < tally rows templates and not found do
    ptn tpl := templates#((i 0) (i 1));
    if "no = (u := unify ptn node) then ok
    else found := o;
      result := each (op x {
        if isconst x then glyph x
        elseif atomic x then x
        else link fmt x endif }) (subs u tpl)
    endif;
    i := i + 1;
  endwhile;
  if empty result then node else link result endif };

(cheq !('∀x(x⇒⊤)')
      !(fmt ("forall "x ("x "implies "top))))



% bitvars (truth tables)
% --------------------------------------------------;

bitvars is OP N {
  rows (1 match transpose BYROWS 0 laminate list tell ( N reshape 2 )) }


cheq !( bitvars 3 ) !([oooollll,oollooll,olololol]);




% axioms of Zermelo-Fraenkel set theory
% --------------------------------------------------;

zf := [
  ("zf.extension
     'Sets with the same members are equal.'
     '∀A ∀B ∀X [(X ∈ A ⇔ X ∈ B) ⇒ (A = B)].'
     ["forall ["A "B "X]
        ["imp ["iff ["mem "X "A] ["mem "X "B]]
              ["eql "A "B]]]
  ),
  ("zf.foundation
     'Every non-empty set contains an element distinct from itself.'
     '∀S[(∃x.x∈S) ⇒ ∃y∈S[∀z∈S[ ¬(z∈y)]]].'
     ["forall ["S]
       ["imp ["exists ["X ["mem "X "S]]
             ["exists ["Y ["mem "Y "S] ["forall ["Z ["mem "Z "S]]
               ["not ["mem "Z "Y]]]]]]]]
  ),
  ("zf.pairing
     'For any pair of sets sets, there is a set containing exactly that pair.'
     '∀A ∀B ∃C ∀y[y∈C ⇔ (y=A ∨ y=B)].'
     ["forall ["A "B] ["exists ["C]  ["forall ["Y]
       ["iff ["mem "Y "C]
             ["vel ["eq "Y "A] ["eq "Y "B ]]]]]]
  ),
  ("zf.infinity
     '(There exists an infinite set.)'
     '∃S[ \empty∈S ∧ (∀x ∈ S)[ X∪{X} ∈ S ]].'
     ["exists ["S]
        ["and ["mem "nil "S]
              ["forall [["X ["mem "X "S]]]
                       ["mem ["union "X ["set "X]]
                             "S]]]]
  ),
  ("zf.union
     'For all sets X and Y, there exists a set containing the union of X and Y.'
     '∀X ∃Y ∀u[u∈Y ⇔ ∃z. (z∈X ∧ u∈z)].'
     ["forall ["X] ["exists ["Y] ["forall "u]
       ["iff ["mem "u "Y]
             ["exists ["Z] ["and ["mem "Z "X] ["mem "U "Z]]]]]]
  ) ];



% zf, continued;

zf := zf link [
  ("zf.powerset
     'The powerset of set X contains every subset of X.'
     '∀X ∃Y ∀u [ u∈Y ⇔ u⊆X ].'
     ["forall ["X] ["exists ["Y] ["forall ["u]
       ["iff ["mem "u "Y] ["sbe "u "y]]]]]
  ),
  ("zf.existence
     'There exists an empty set.'
     '∃S ∀X[¬(X∈S)].'
     ["exists ["S] ["forall ["X]
       ["not ["mem "X "S]]]]
  ),
  ("zf.separation
     'Predicate functions can partition a set.'
     '∀P∈(a → Bit)[∀z∃x∀y(y∈x ⇒ (y∈z ∧ P(y)))].'
     ["schema ["P ["mem "P ["fun "$a "bit]]]
       ["forall ["Z "Y] ["exists ["X]
          ["imp ["mem "Y "X]
                ["and ["mem "Y "Z] ["P "y]]]]]]
  ),
  ("zf.replacement
     'Functions map sets onto sets.'
     ''
     ["schema ["F]
       ["imp ["forall ["X "Y "Z]
               ["imp ["and ["F "X "Y "p] ["F "X "Z "p]]
                 ["eql "Y "Z]]]
             ["forall ["X "Y "y]
               ["iff ["mem "y "Y]
                     ["exists ["x ["mem "x "X]]
                        ["F "x "y "p]]]]]]
  ) ];
